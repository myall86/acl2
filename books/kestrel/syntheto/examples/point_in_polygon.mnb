{
  "cells": [
    {
      "kind": 2,
      "language": "syntheto",
      "value": "struct point {\n  x: int,\n  y: int\n}\n\nstruct edge {\n  p1: point,\n  p2: point\n}\nfunction even(i:int) returns (b:bool) {\n  return i % 2 == 0;\n}\n\nfunction odd(i:int) returns (b:bool) {\n  return !even(i);\n}\n\nfunction natp(i:int) returns (b:bool) {\n  return i >= 0;\n}\n\nfunction max(x: int, y: int) returns (m: int) {\n  if (y > x) {\n    return y;\n  }\n  else {\n  return x;\n  }\n}\n\nfunction min(x: int, y: int) returns (m: int) {\n  if (y < x) {\n    return y;\n  }\n  else {\n  return x;\n  }\n}\nfunction max_x(vertices: seq<point>) returns (m: int) ensures m >= 0 {\n  if (is_empty(vertices)) {\n   return 0;\n  }\n  else {\n    let v1: point = first(vertices);\n    return max(v1.x,\n               max_x(rest(vertices)));\n  }\n}\ntheorem odd_of_plus_1\n  forall (i:int)\n    odd(1+i) == !odd(i)\nfunction connected(e1:edge, e2:edge) returns (b:bool) {\n  return e1.p2 == e2.p1;\n}\n\nfunction path_p(edges:seq<edge>) returns (b:bool) {\n  return length(edges) <= 1\n        || (connected(first(edges), first(rest(edges)))\n             && path_p(rest(edges)));\n}\n\ntheorem path_p_rest\n  forall(edges:seq<edge>)\n    !is_empty(edges) && path_p(edges)\n      ==> path_p(rest(edges))\n      \n// Given a list of points, return the list of edges\n// that connect the points in sequence\nfunction path(vertices:seq<point>) returns (p:seq<edge>) ensures path_p(p) {\n  if (is_empty(vertices) || is_empty(rest(vertices))) {\n    return empty;\n  }\n  else {\n    let e: edge = edge(p1=first(vertices), p2=first(rest(vertices)));\n    return add(e, path(rest(vertices)));\n  }\n}\ntheorem not_empty_path\n  forall(vertices:seq<point>)\n    !is_empty(vertices) && !is_empty(rest(vertices))\n      ==> !is_empty(path(vertices))\ntheorem length_path\n  forall(vertices:seq<point>)\n    !is_empty(vertices)\n      ==> length(path(vertices)) == length(vertices) - 1\n\nfunction points2_p (vertices:seq<point>) returns (b: bool) {\n  return is_empty(vertices) || !is_empty(rest(vertices));\n}\n\nfunction path_vertices(edges:seq<edge>) returns (vertices:seq<point>) ensures points2_p(vertices) {\n  if (is_empty(edges)) {\n    return empty;\n  }\n  else {\n  let e:edge = first(edges);\n  if (is_empty(rest(edges))) {\n    return add(e.p1, add(e.p2, empty));\n  }\n  else {\n    return add(e.p1, path_vertices(rest(edges)));\n  }\n  }\n}\n\n// Inversion Theorems \ntheorem path_vertices_of_path\n  forall(vertices:seq<point>)\n    points2_p(vertices)\n      ==> path_vertices(path(vertices)) == vertices\n\ntheorem path_of_path_vertices\n  forall(edges:seq<edge>)\n    path_p(edges)\n      ==> path(path_vertices(edges)) == edges\n      \nfunction append_first(vertices:seq<point>) assumes !is_empty(vertices) \n  returns (s: seq<point>) ensures points2_p(s) {\n  return append(vertices, add(first(vertices), empty));\n}\n// Given a list of points, return the list of edges\n// that connect the points in sequence, then connect\n// the last point to the first point.\nfunction edges(vertices: seq<point>) returns (p: seq<edge>) ensures path_p(p) {\n  if (is_empty(vertices)) {\n    return empty;\n  }\n  else {\n    return path(append_first(vertices));\n  }\n}\n\ntheorem path_vertices_of_edges\n  forall(vertices:seq<point>)\n   !is_empty(vertices)\n    ==> path_vertices(edges(vertices)) == append_first(vertices)\n\n// Orientation of an ordered triplet of points in the plane can be\n//   . clockwise\n//   . counterclockwise, or\n//   . colinear\n// It can be computed by the sign of the expression\n//   (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.y - p1.x)\n// If the expression is positive, the orientation is counterclockwise\n// If the expression is 0, the orientation is collinear\n// If the expression is negative the orientation is counterclockwise\n// (See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n// for some explanations on this concept)\n\nvariant orientation {clockwise, counterclockwise, colinear}\nfunction orientation3(p1: point, p2: point, p3: point) returns (o: orientation) {\n  if (p1 == p2 || p2 == p3 || p2 == p3) {\n    return orientation.colinear;\n  }\n  else {\n    let e: int = (p2.y - p1.y) * (p3.x - p2.x) - (p3.y - p2.y) * (p2.y - p1.x);\n    if (e < 0) {\n      return orientation.counterclockwise;\n    }\n    else {if (e == 0) {\n      return orientation.colinear;\n    }\n    else {\n      return orientation.clockwise;\n    }}}\n}\n\nfunction collinear(p1: point, p2: point, p3: point) returns (b:bool) {\n  return orientation3(p1,p2,p3) == orientation.colinear;\n}\nfunction on_segment(p1: point, p2: point, p3: point) returns (b: bool) {\n  return p3.x >= min(p1.x, p2.x)\n           && p3.x <= max(p1.x, p2.x)\n           && p3.y >= min(p1.y, p2.y)\n           && p3.y <= max(p1.y, p2.y);\n}\n// return true when edge1 and edge1 intersect\n// see https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\nfunction edge_points_intersect(p11:point, p12:point, p21:point, p22:point) returns (b: bool) {\n  let o1: orientation = orientation3(p11, p12, p21);\n  let o2: orientation = orientation3(p11, p12, p22);\n  let o3: orientation = orientation3(p21, p22, p11);\n  let o4: orientation = orientation3(p21, p22, p12);\n  return ((o1 != o2 && o3 != o4)   // Non colinear case\n           // Special cases\n           || (o1 == orientation.colinear && on_segment(p11, p12, p21))\n           || (o2 == orientation.colinear && on_segment(p11, p12, p22))\n           || (o3 == orientation.colinear && on_segment(p21, p22, p11))\n           || (o4 == orientation.colinear && on_segment(p21, p22, p12)));\n}\n\nfunction edges_intersect(edge1: edge, edge2: edge) returns (b: bool) {\n  return edge_points_intersect(edge1.p1, edge1.p2, edge2.p1, edge2.p2);\n}\n// return true when no three adjacent points in a list are collinear\nfunction adjacent_three_points_not_collinear(vertices: seq<point>) returns (b: bool) {\n  if (is_empty(vertices) || is_empty(rest(vertices)) || is_empty(rest(rest(vertices)))) {\n    return true;\n  }\n  else {\n    return ! collinear(first(vertices),\n                       first(rest(vertices)),\n                       first(rest(rest(vertices))))\n            && (adjacent_three_points_not_collinear(rest(vertices)));\n  }\n}\nfunction edge_does_not_intersect_edges(edge0: edge, edges: seq<edge>) returns (b: bool) {\n  if (is_empty(edges)) {\n    return true;\n  }\n  else {\n    return ! edges_intersect(edge0, first(edges))\n            && edge_does_not_intersect_edges(edge0, rest(edges));\n  }\n}\n// return true when no two non-adjacent edges in a list intersect\nfunction non_adjacent_edges_do_not_intersect(edges: seq<edge>) returns (b: bool) {\n  if (is_empty(edges) || is_empty(rest(edges)) || is_empty(rest(rest(edges)))) {\n    return true;\n  }\n  else {if (edge_does_not_intersect_edges(first(edges), rest(rest(edges)))) {\n    return non_adjacent_edges_do_not_intersect(rest(edges));\n  }\n  else {\n    return false;\n  }}\n}\n// A simple polygon is built from a sequence of n (>= 3) distinct vertices\n//   v_1, v_2, ..., v_n\n// by connecting the vertices in order and then connecting the last vertex\n// with the first vertex, forming a closed polygonal chain of n edges\n//   (v_1, v_2), (v_2, v_3), ...., (v_n-1, v_n), (v_n, v_1)\n// Additionally,\n// - adjacent three points must not be collinear, and\n// - non-adjacent edges must not intersect\nfunction simple_polygon(vertices: seq<point>) returns (b: bool) {\n  return length(vertices) >= 3\n          // Maybe need condition that no two points repeated\n          // with possible exception that the first and last points are the same\n          && adjacent_three_points_not_collinear(vertices)\n          && non_adjacent_edges_do_not_intersect(edges(vertices));\n}\n\ntheorem simple_polygon_implies_not_empty\n  forall (vertices: seq<point>)\n    simple_polygon(vertices)\n      ==> !is_empty(vertices)\n/* number of times edge0 crosses  edges */\nfunction crossings_count_aux(edge0: edge, edges: seq<edge>) assumes path_p(edges)\n  returns (n: int) ensures n >= 0 {\n  if (is_empty(edges)) {\n    return 0;\n  }\n  else {if (edges_intersect(edge0, first(edges))) {\n    return 1 + crossings_count_aux(edge0, rest(edges));\n  }\n  else {\n   return crossings_count_aux(edge0, rest(edges));\n  }}\n}\n/* Number of times a ray starting from the given point crosses the edges of a polygon */\nfunction crossings_count(p: point, polygon: seq<point>) assumes simple_polygon(polygon)\n  returns (n: int) ensures n >=0 {\n  let pm:point = point(x=max_x(polygon) + 1, y=p.y);  // point outside polygon\n  let e:edge = edge(p1 = p, p2 = pm);\n  return crossings_count_aux(e, edges(polygon));\n}\nfunction point_in_polygon(p: point, polygon: seq<point>) assumes simple_polygon(polygon)\n  returns (b: bool) {\n  return odd(crossings_count(p, polygon));\n}\n// Introduced because syntheto doesn't currently have conditional expressions\nfunction rest1(vertices:seq<point>) assumes !(is_empty(vertices) || is_empty(rest(vertices))) \n  returns (vs:seq<point>) ensures points2_p(vs) {\n  if (is_empty(rest(rest(vertices)))) {\n    empty;}\n  else {\n    rest(vertices);\n    }\n}\n\n/* Simplification rules */\n\ntheorem length_rest1_decreases\n  forall(vertices:seq<point>)\n    !(is_empty(vertices) || is_empty(rest(vertices)))\n     ==> length(rest1(vertices)) < length(vertices)\n\ntheorem path_vertices_of_rest_of_path_non_empty\n  forall(vertices:seq<point>)\n    !(is_empty(vertices) || is_empty(rest(vertices)))\n     ==> path_vertices(rest(path(vertices))) == rest1(vertices)\n\ntheorem length_path_rest1_decreases\n  forall(vertices:seq<point>)\n    !(is_empty(vertices) || is_empty(rest(vertices)))\n     ==> 1 + length(path(rest1(vertices)))< length(vertices)\n     \n// Needed?\ntheorem is_empty_path\n  forall(vertices:seq<point>)\n    is_empty(path(vertices)) == (is_empty(vertices) || is_empty(rest(vertices)))\n\ntheorem p1_first_path\n  forall(vertices:seq<point>, path1:edge)\n    !is_empty(vertices) && !is_empty(rest(vertices))\n      && path1 == first(path(vertices))\n     ==> path1.p1 == first(vertices)\n\ntheorem p2_first_path\n  forall(vertices:seq<point>, path1:edge)\n    !is_empty(vertices) && !is_empty(rest(vertices))\n      && path1 == first(path(vertices))\n     ==> path1.p2 == first(rest(vertices))\n\n/* Derivation */\n\nfunction crossings_count_aux_1 =\n  transform crossings_count_aux\n    by tail_recursion {new_parameter_name = count}\n\nfunction crossings_count_aux_2 =\n  transform crossings_count_aux_1\n    by isomorphism {parameter = edges,\n                    new_parameter_name = vertices,\n                    old_type = path_p,\n                    new_type = points2_p,\n                    old_to_new = path_vertices,\n                    new_to_old = path,\n                    simplify = true}\n\nfunction crossings_count_aux_3 =\n  transform crossings_count_aux_2\n    by wrap_output {wrap_function = odd}\n\n/*\nfunction crossings_count_aux_4 =\n  transform crossings_count_aux_3\n    by finite_difference {expression = odd(count),\n                          new_parameter_name = count_odd,\n                          simplify = true}\n*/\n/*\nfunction crossings_count_aux_5 =\n  transform crossings_count_aux_4\n    by drop_irrelevant_param {param = count}\n*/\n\nfunction crossings_count_1 =\n  transform crossings_count\n    by wrap_output {wrap_function = odd}\n\nfunction crossings_count_2 =\n  transform crossings_count_1\n    by simplify\n\nfunction point_in_polygon_final =\n  transform point_in_polygon\n    by simplify",
      "editable": true
    }
  ]
}